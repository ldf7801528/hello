<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../css/reset.css">
    <!--[if lt IE 9]>
    <script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
    <![endif]-->
    <style>
        canvas {
            border: 1px solid #dddddd;
            border-radius: 10px;
        }
        div {
            width: 200px;
            height: 200px;
            border: 1px solid #ff0000;
        }
        .text1 {
            width:200px;
            overflow:hidden;
            text-overflow:ellipsis;
            -o-text-overflow:ellipsis;
            -webkit-text-overflow:ellipsis;
            -moz-text-overflow:ellipsis;
            white-space:nowrap;
            
        }
        .text2 {
            width:200px;
            word-break:break-all;
            display:-webkit-box;
            -webkit-line-clamp:2;
            -webkit-box-orient:vertical;
            overflow:hidden;
        }
        @media all and (orientatiion:landscape) {
            
        }
        @media all and (orientation:portrait) {
            
        }
        @media X and (min-width: 200px) {

        }
        @media all and (min-height: 640px) and (max-height: 960px) {

        }
        @media only screen and (-moz-min-device-pixel-ratio: 1), only screen and (-o-min-device-pixwl-ratio: 1),
               only screen and (-webkit-min-device-pixel-ratio:1){
            .header {

            }
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="300" height="150"></canvas>
    <div></div>
    <canvas id="cube" width="300" height="150"></canvas>
    <div class="text1">热卖精选：从子频道（服饰鞋包，亲子，居家，美妆）档期里面挑选出来，库存大于30%的高信价比商品list，数量为50个      </div>

    <br />

    <div class="text2">热卖精选：从子频道（服饰鞋包，亲子，居家，美妆）档期里面挑选出来，库存大于30%的高信价比商品list，数量为50个
    </div>
<script>
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");

    var grd = ctx.createLinearGradient(0,0,200,0);
    grd.addColorStop(0,"red");
    grd.addColorStop(1,"white");
    ctx.fillStyle = grd;
    ctx.fillRect(10,10,150,80);
    //ctx.font = "30px Arial";
    //ctx.fillText("Hello World",10,50);
    //ctx.strokeText("Hello World",10,50);
    //ctx.beginPath();
    //ctx.arc(95,50,40,0,2*Math.PI);

    //ctx.moveTo(0,0);
    // ctx.lineTo(300,150);
    //ctx.stroke();
    //ctx.fillStyle = "#ff0000";
    //ctx.fillRect(0,0,150,75);
    var cube = (function(){
        var canvas = document.getElementById('cube'),
                ctx = canvas.getContext('2d'),
                width = 102,
                height = 90,
                centerX = (width / 2),
                centerY = (height / 2) - 2,
                side = 20,
                perspective = 200,
                xStart = .45, yStart = .85, zStart = 0,
                xEnd = xStart, yEnd = yStart, zEnd = zStart,
                xRot = xStart, yRot = yStart, zRot = zStart,
                duration,
                startTime,
                mCos = Math.cos,
                mSin = Math.sin,
                mRound = Math.round,
                PI = Math.PI,
                animationTimer,
                initTimer,
                nextFrame = (function() {
                    return window.requestAnimationFrame
                            || window.webkitRequestAnimationFrame
                            || window.mozRequestAnimationFrame
                            || window.oRequestAnimationFrame
                            || window.msRequestAnimationFrame
                            || function(callback) { return setTimeout(callback, 16.667); }
                })(),
                cancelFrame = (function () {
                    return window.cancelRequestAnimationFrame
                            || window.webkitCancelRequestAnimationFrame
                            || window.mozCancelRequestAnimationFrame
                            || window.oCancelRequestAnimationFrame
                            || window.msCancelRequestAnimationFrame
                            || clearTimeout
                })(),

                cube = [
                    [-side, side, side, side, side, side, side, -side, side, -side, -side, side, 0, 0, 255],
                    [-side, side, -side, side, side, -side, side, -side, -side, -side, -side, -side, 0, 0, -255],
                    [side, side, side, side, side, -side, side, -side, -side, side, -side, side, 255, 0, 0],
                    [-side, side, side, -side, side, -side, -side, -side, -side, -side, -side, side, -255, 0, 0],
                    [-side, -side, side, side, -side, side, side, -side, -side, -side, -side, -side, 0, -255, 0],
                    [-side, side, side, side, side, side, side, side, -side, -side, side, -side, 0, 255, 0]
                ];

        function draw () {
            var rotation = [],
                    x, y, z,
                    r, g, b,
                    i, l,
                    color,
                    easeOut,
                    now = (new Date).getTime();

            for (i=0; i<6; i++) {
                rotation[i] = [];

                for (l=0; l<15; l+=3) {
                    // X rotation
                    x = cube[i][l];
                    y = cube[i][l+1];
                    z = cube[i][l+2];
                    rotation[i][l] = x;
                    rotation[i][l+1] = mCos(xRot) * y + mSin(xRot) * z;
                    rotation[i][l+2] = mCos(xRot) * z - mSin(xRot) * y;

                    // Y rotation
                    x = rotation[i][l];
                    y = rotation[i][l+1];
                    z = rotation[i][l+2];
                    rotation[i][l] = mCos(yRot) * x - mSin(yRot) * z;
                    rotation[i][l+1] = y;
                    rotation[i][l+2] = mCos(yRot) * z + mSin(yRot) * x;

                    // Z rotation
                    x = rotation[i][l];
                    y = rotation[i][l+1];
                    z = rotation[i][l+2];
                    rotation[i][l] = mCos(zRot) * x - mSin(zRot) * y;
                    rotation[i][l+1] = mCos(zRot) * y + mSin(zRot) * x;
                    rotation[i][l+2] = z;

                    // Perspective
                    x = rotation[i][l];
                    y = rotation[i][l+1];
                    z = rotation[i][l+2];
                    rotation[i][l] = (x * perspective) / (perspective - z);
                    rotation[i][l+1] = (y * perspective) / (perspective - z);
                    rotation[i][l+2] = z;
                }
            }

            ctx.clearRect(0,0, width, height);

            for (i=0; i<6; i++) {
                color = Math.round(rotation[i][14]);
                if (color > 255) color = 255;

                if (color > 22) {
                    r = Math.round(color / 255 * 79);
                    g = Math.round(color / 255 * 78);
                    b = Math.round(color / 255 * 72);
                    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.strokeStyle = 'rgb(24,24,22)';
                    ctx.beginPath();
                    ctx.moveTo(rotation[i][0] + centerX, rotation[i][1] + centerY);
                    ctx.lineTo(rotation[i][3] + centerX, rotation[i][4] + centerY);
                    ctx.lineTo(rotation[i][6] + centerX, rotation[i][7] + centerY);
                    ctx.lineTo(rotation[i][9] + centerX, rotation[i][10] + centerY);
                    ctx.lineTo(rotation[i][0] + centerX, rotation[i][1] + centerY);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            if (now >= startTime + duration) {
                initTimer = setTimeout(init, 2500);
                return;
            }

            if (now < startTime + duration) animationTimer = nextFrame(draw);

            now = (now - startTime) / duration;

            ease = -.5 * (mCos(PI * now) - 1);
            xRot = ease * (xEnd - xStart) + xStart;
            yRot = ease * (yEnd - yStart) + yStart;
            zRot = ease * (zEnd - zStart) + zStart;
        }

        function init () {
            clearTimeout(initTimer);
            cancelFrame(animationTimer);

            xStart = xRot;
            yStart = yRot;
            zStart = zRot;
            xEnd = Math.random() * 20 + 5;
            yEnd = Math.random() * 20 + 5;
            zEnd = Math.random() * 20 + 5;
            duration = startTime ? 15000 / 25 * (Math.max(xEnd, yEnd, zEnd)) : 0;

            startTime = Date.now();

            draw();
        }

        canvas.onclick = init;

        return {
            init: init,
            stop: function () { clearTimeout(initTimer); cancelFrame(animationTimer); }
        }
    })();

    // Ignite!
    cube.init();
    window.addEventListener('load', function () { setTimeout(cube.init, 200); }, false);

</script>
</body>
</html>